param(
  [string]$WhisperExe = "C:\ai\whisper\Release\whisper-stream.exe",
  [string]$Model      = "C:\ai\models\ggml-small.en.bin",
  [int]$MicIndex      = 0,
  [string]$EchoHome   = $env:ECHO_HOME,
  [string]$UserName   = "user"
)

# Defaults
if (-not $EchoHome) { $EchoHome = "D:\Echo" }
$Inbox = Join-Path $EchoHome "ui\inboxq"
New-Item -ItemType Directory -Force -Path $Inbox | Out-Null

# Sanity checks
if (-not (Test-Path $WhisperExe)) { throw "whisper-stream.exe not found: $WhisperExe" }
if (-not (Test-Path $Model))      { throw "Model not found: $Model" }

# Launch whisper-stream with stdout captured
$psi = New-Object System.Diagnostics.ProcessStartInfo
$psi.FileName = $WhisperExe
$psi.Arguments = "-m `"$Model`" -c $MicIndex"
$psi.RedirectStandardOutput = $true
$psi.RedirectStandardError  = $true
$psi.UseShellExecute = $false
$psi.CreateNoWindow = $true

$p = New-Object System.Diagnostics.Process
$p.StartInfo = $psi
[void]$p.Start()

$stdout = $p.StandardOutput
$stderr = $p.StandardError

Write-Host "whisper-stream running. Mic=$MicIndex  Model=$Model" -ForegroundColor Green
Write-Host "Piping recognized lines into $Inbox" -ForegroundColor Green
[Console]::OutputEncoding = [Text.UTF8Encoding]::UTF8

# Simple coalescing: accumulate partials until punctuation or long-enough line, then flush one .txt
$buf = ""
function Flush-Buf {
  param([string]$Reason)
  $text = $script:buf.Trim()
  if (-not [string]::IsNullOrWhiteSpace($text)) {
    $ts = (Get-Date).ToString("yyyyMMdd-HHmmss-fff")
    $path = Join-Path $Inbox "$ts`_$UserName.txt"
    Set-Content -Path $path -Value $text -NoNewline -Encoding UTF8
    Write-Host "[sent] $text" -ForegroundColor Cyan
  }
  $script:buf = ""
}

try {
  while (-not $p.HasExited) {
    $line = $stdout.ReadLine()
    if ($null -eq $line) { Start-Sleep -Milliseconds 10; continue }

    $line = $line.Trim()
    if ([string]::IsNullOrWhiteSpace($line)) { continue }

    # Heuristics: ignore obvious status/progress lines; keep only speech text.
    # Tweak these if your stream prints different prefixes.
    if ($line -match '^\s*(\[[^\]]+\]|partial:|info:|note:|->)') { continue }

    # Append to buffer
    if ($buf) { $buf += " " }
    $buf += $line

    # If line looks complete (ends in . ! ? or long enough), emit one message
    if ($line -match '[\.\!\?]$' -or $buf.Length -ge 60) {
      Flush-Buf "punct/length"
    }
  }
} finally {
  if ($buf.Trim()) { Flush-Buf "shutdown" }
  if (-not $p.HasExited) { $p.Kill() }
}

