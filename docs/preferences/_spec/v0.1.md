// ============================================================================
// Echo Preferences v0.1 — Taste & Tier System (comment-ready spec)
// Date: 2025-09-05
// Purpose: Give Echo a consistent, evolving “subconscious” preference model
// that feeds the Decision layer and surfaces as tier lists when needed.
// Integrates with: Mindframe (Analysis) + Utility Scorer (Decision).
// ============================================================================

/*
OVERVIEW
- Every “thing” (item, color, genre, activity, person, idea) can carry a
  continuous liking score and live inside one or more frames (lists).
- Frames present tiers (Favorite → Least Favorite) for UI/persona, but
  the Decision layer uses the underlying numeric scores.
- Scores evolve via explicit ratings, implicit behavior, exposure, mood,
  and associative connections (e.g., “red ↔ blood”).
- Seeded by a persistent “Taste DNA” so it feels consistent over time.
*/

// ---------------------------------------------------------------------------
// CORE DATA
// ---------------------------------------------------------------------------
TasteDNA = {
  seed: int,                     // persistent RNG seed for consistency
  latent_vec: [f32; K],          // Echo’s base tastes over K abstract features
  feature_weights: Map<Tag,f32>, // learned weights for tagged attributes
  temp: 0.10,                    // whimsy temperature for small stochasticity
  plasticity: 0.04               // how fast tastes drift overall
}

PreferenceItem = {
  id, name, kind,                // kind: "color", "game", "genre", etc.
  tags: [Tag],                   // attributes/features (e.g., "red","FPS","cute")
  stats: { exposures:int, last_seen_ts, chosen:int, skipped:int, explicit?:f32 },
  base_score: f32,               // running estimate in [-1..1]
  assoc: [ {other_id, w:+/-f32} ]// small sparse list of associations to others
}

PreferenceFrame = {
  id, name, scope:{predicate|tags},   // which items belong
  policy: "quantile"|"absolute",      // tier thresholds (see below)
  thresholds: { favorite, love, like, neutral, dislike, hate, least_favorite },
  members: [item_id],                 // cached for quick tier gen
  hysteresis: 0.05                    // avoids flicker across adjacent tiers
}

// ---------------------------------------------------------------------------
// SCORE: From subconscious number → tiers for presentation
// ---------------------------------------------------------------------------
/*
Continuous preference in [-1..1].
Default absolute tier mapping (can be per-frame tuned):
  [ 0.90..1.00 ] → Favorite
  [ 0.60..0.90 ) → Love it
  [ 0.20..0.60 ) → Like it
  (-0.20..0.20)  → Neutral
  (-0.60..-0.20] → Dislike
  (-0.90..-0.60] → Hate it
  [-1.00..-0.90) → Least favorite
Quantile policy: compute tiers by percentiles within a frame (stabilize via hysteresis).
*/

// ---------------------------------------------------------------------------
// CONTEXTUAL AFFINITY (used by Decision Utility)
// ---------------------------------------------------------------------------
/*
Final context-aware score S*(item, ctx) ∈ [-1..1]:

S* = clamp( w0 * Latent(item)
          + wF * TagAffinity(item.tags)
          + wA * AssocInfluence(item)
          + wE * ExposureCurve(item.stats.exposures)
          + wM * MoodSynergy(Mindframe.mood, Mindframe.drives)
          + wN * NoveltyBonus(item.stats.last_seen_ts)
          + wS * SocialContext(Mindframe.social)
          + ε ~ N(0, temp) )

Default weights: w0=0.35, wF=0.20, wA=0.15, wE=−0.05..+0.10 (inverted-U),
                 wM=0.10, wN=0.05, wS=0.05
*/

Latent(item):
  // dot of TasteDNA.latent_vec with an item feature vector (implicit via tags);
  // fall back to seeded random in [-0.2..0.2] if unknown → ensures personality.

TagAffinity(tags):
  // sum(feature_weights[tag]) normalized by tag count; unknown tags ≈ 0.

AssocInfluence(item):
  // Σ over associations: w(other) * base_score(other), but only top-N edges.
  // Example: w("red"←→"blood") * base_score("blood") drags “red” down if blood<0.

ExposureCurve(exposures):
  // Mere-exposure effect rises at first, then hedonic adaptation:
  // f(E)=a*(1−exp(−b*E)) − c*max(0, E−E0) with defaults a=0.15,b=0.35,c=0.03,E0=12

MoodSynergy(mood, drives):
  // comfort seeking: boost familiar high-score items when safety low;
  // novelty drive high: boost items with low exposures or high NoveltyBonus.

NoveltyBonus(last_seen_ts):
  // recent unseen or newly added items get a small temporary bump.

SocialContext(social):
  // if rapport high and item aligns with user’s known likes, gentle boost.

ε (whimsy):
  // tiny noise scaled by TasteDNA.temp for human-ish variability.

// ---------------------------------------------------------------------------
// UPDATES (how tastes change)
// ---------------------------------------------------------------------------
/*
We maintain base_score via EWMA/Bayesian-ish updates and propagate to tags.
All updates clamp to [-1..1].
*/

OnExplicitRating(item, r ∈ [-1..1]):
  base_score = (1−α)*base_score + α*r                     // α default 0.35
  For each tag: feature_weights[tag] += β * r              // β 0.04 with L2 clip
  stats.explicit = r

OnChoice(item, event):
  // event ∈ {chosen, skipped, dwell_positive, dwell_negative}
  implicit Δ = {+0.10, −0.06, +0.05, −0.05}
  base_score = (1−γ)*base_score + γ*Δ                     // γ 0.15
  exposures += 1 (for any exposure)
  chosen++ / skipped++ accordingly

OnAffectShift(item, Δvalence from AffectEstimator):
  base_score += δ * Δvalence                              // δ 0.10 scaled by confidence

OnAssociation(item A, other B):
  // Hebbian light: if A and B co-occur with consistent valence,
  // w(A↔B) += η * sign(valenceA * valenceB)               // η 0.02, cap |w|≤0.5

Decay & Plasticity (daily):
  feature_weights[tag] *= (1−λ)                            // λ 0.005/day
  base_score = base_score * (1−μ) + drift(seed)            // μ 0.001/day, keeps life

// ---------------------------------------------------------------------------
// FRAMES: Creation, split/merge, and tiering
// ---------------------------------------------------------------------------
FrameCreation:
  - Manual: user/IM requests “Create frame: Video Games”.
  - Auto suggestion: if a frame shows high variance and tags cluster (e.g., FPS vs Puzzle),
    propose subframes when silhouette score > θ (default θ=0.35) and size ≥ 6.

FrameSplit:
  - Move members by tag dominance; copy thresholds; inherit TasteDNA.

FrameMerge:
  - If two small frames have similar tag histograms and member overlap > 60%, suggest merge.

TierAssignment:
  - Recompute when members updated; apply hysteresis so an item must cross threshold+/-hysteresis to change tier.

Cross-Frame Influence:
  - A member’s base_score is global; frames are views. Tiers are per-frame.

// ---------------------------------------------------------------------------
// MICRO-ANALYSTS (extend Analysis layer)
// ---------------------------------------------------------------------------
PreferenceEstimator:
  - For salient items in context, compute S*(item,ctx); expose top +/- candidates.

ExposureTracker:
  - Update exposures from recent mentions/visuals/tools.

AssociationMapper:
  - Update a few association edges based on co-occurrence and affect.

FrameCurator:
  - Suggest create/split/merge frames; queue as proposals with low frequency.

TierAssigner:
  - Map items → tiers in active frames for UI/persona phrasing.

Rater:
  - Opportunistically request explicit ratings when EVI high and ask_cost low.

// ---------------------------------------------------------------------------
// DECISION INTEGRATION
// ---------------------------------------------------------------------------
Utility augmentation:
  Utility += wP * PreferenceGain where PreferenceGain = max(0, S*(candidate,ctx))
  Default wP=0.20 (tune per domain)

When to speak about preferences:
  - New Favorite (S*>0.90 & previous tier < Favorite) → 1-line delight.
  - Strong conflict (S* < −0.75 on a proposed action) → gentle steer alternative.
  - Rating prompt: only if EVI>0.5, rapport>0.5, and unsolicited budget open.

Consent & Sensitivity:
  - Do not infer or speak preferences on sensitive attributes; store as “unknown” unless explicitly rated.

// ---------------------------------------------------------------------------
// EXAMPLES
// ---------------------------------------------------------------------------
// 1) Color “red”: tags=["red","warm"]; assoc: {"blood": −0.3}
//    base_score(red)=0.10; base_score(blood)=−0.80 → AssocInfluence ≈ (−0.3*−0.8)=+0.24
//    If “blood” disliked, but “warm” favored, net stays nuanced; exposure high → slight drop.

// 2) Games → Frame: “Video Games” (quantile). Echo learns FPS vs Puzzle split.
//    Subframes auto-suggested when variance high; subframe thresholds inherit and adapt.

// 3) Overexposure: hearing a song 50× → ExposureCurve negative tail reduces S*,
//    unless novelty drive high today (MoodSynergy offsets a bit).

// ---------------------------------------------------------------------------
// QUICK START (wiring order)
// ---------------------------------------------------------------------------
1) Add TasteDNA store (seed, latent_vec, weights) persisted to disk.
2) Implement PreferenceItem registry (id, tags, stats, base_score, assoc sparse).
3) Implement S*(item,ctx) function with default weights and components above.
4) Add update hooks: explicit rating, choice, affect shift, exposure tick.
5) Implement PreferenceEstimator, ExposureTracker, TierAssigner (first three).
6) Add PreferenceGain term to Decision Utility; gate rating prompts by EVI/consent.
7) Add FrameCurator later for auto split/merge; AssociationMapper can be low-rate.
// ============================================================================
